<!DOCTYPE html><html><head><title>Koa - 下一代 Node.js web 框架</title><link rel="stylesheet" href="public/style.css"><link rel="shortcut icon" href="favi.co"><link rel="stylesheet" href="public/icons/css/slate.css"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Italiana&amp;subset=latin"><meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta charset="utf8"><meta name="keywords" content="Koa, Koajs, Node, Web框架, generator, RedNode"><meta name="description" content="Express原班团队打造的下一代 Node.js web 框架, 全新架构, 核心代码精简, 全新的流程书写代码-Koajs"></head><body><section id="top"><div id="menu"><a id="toggle" href="#"><i class="icon-menu"></i></a><ul><li><a href="#introduction">Introduction</a></li><li><a href="#application">Application</a></li><li><a href="#context">Context</a></li><li><a href="#request">Request</a></li><li><a href="#response">Response</a></li><li><a href="#guide">Guide</a></li><li><a href="#links">Links</a></li><li><a href="http://koajs.com" target="_blank">Koajs.com</a></li></ul></div><div id="heading"><div id="logo">Koa</div><div id="tagline">下一代 Node.js web 框架</div></div></section><section><div class="content"><h1 id="introduction">简介</h1><p>由 Express 原班人马打造的 koa，致力于成为一个更小、更健壮、更富有表现力的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升常用错误处理效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。
</p></div></section><section><div class="content"><h1 id="-koa">安装 koa</h1>
<p>  koa 依赖支持 generator 的 Node 环境，准确来说，是 <code>node &gt;= 0.11.9</code> 的环境。</p>
<pre><code>$ npm install koa</code></pre>
<p>  安装完成后，应确保使用 <code>$ node app.js --harmony</code> 或(--harmony-generators) 即，harmony 模式运行程序。</p>
<p>  为了方便，可以将 <code>node</code> 设置为默认启动 harmony 模式的别名：</p>
<pre><code>alias node=&#39;node --harmony&#39;</code></pre>
<p>  还可以使用 <a href="https://github.com/TooTallNate/gnode">gnode</a> 运行程序, 但执行效率会较低.</p>
<h1 id="application">Application</h1>
<p>  一个 Koa Application（以下简称 app）由一系列 generator 中间件组成。按照编码顺序在栈内依次执行，从这个角度来看，Koa app 和其他中间件系统（比如 Ruby Rack 或者 Connect/Express ）没有什么太大差别，不过，从另一个层面来看，Koa 提供了一种基于底层中间件编写「语法糖」的设计思路，这让设计中间件变得更简单有趣。</p>
<p>  在这些中间件中，有负责内容协商（content-negotation）、缓存控制（cache freshness）、反向代理（proxy support）与重定向等等功能的常用中间件（详见 <a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6middleware">中间件</a> 章节），但如前所述， Koa 内核并不会打包这些中间件，让我们先来看看 Koa 极其简单的 Hello World 应用程序：</p>
<p>  Hello world:</p>
<pre><code class="lang-js">var koa = require(&#39;koa&#39;);
var app = koa();

app.use(function *(){
  this.body = &#39;Hello World&#39;;
});

app.listen(3000);</code></pre>
<p><strong>译者注：</strong> 与普通的 function 不同，generator functions 以 <code>function*</code> 声明。以这种关键词声明的函数支持 <code>yield</code></p>
<h2 id="-cascading-">代码级联（Cascading）</h2>
<p>  Koa 中间件以一种非常传统的方式级联起来，你可能会非常熟悉这种写法。</p>
<p>  在以往的 Node 开发中，频繁使用回调不太便于展示复杂的代码逻辑，在 Koa 中，我们可以写出真正具有表现力的中间件。与 Connect 实现中间件的方法相对比，Koa 的做法不是简单的将控制权依次移交给一个又一个的中间件直到程序结束，Koa 执行代码的方式有点像回形针，用户请求通过中间件，遇到 <code>yield next</code> 关键字时，会被传递到下一个符合请求的路由（downstream），在 <code>yield next</code> 捕获不到下一个中间件时，逆序返回继续执行代码（upstream）。</p>
<p>  下边这个例子展现了使用这一特殊方法书写的 Hello World 范例：一开始，用户的请求通过 x-response-time 中间件和 logging 中间件，这两个中间件记录了一些请求细节，然后「穿过」 response 中间件一次，最终结束请求，返回 「Hello World」。</p>
<p>  当程序运行到 <code>yield next</code>时，代码流会暂停执行这个中间件的剩余代码，转而切换到下一个被定义的中间件执行代码，这样切换控制权的方式，被称为downstream，当没有下一个中间件执行 downstream 的时候，代码将会逆序执行。</p>
<pre><code class="lang-js">var koa = require(&#39;koa&#39;);
var app = koa();

// x-response-time

app.use(function *(next){
  var start = new Date;
  yield next;
  var ms = new Date - start;
  this.set(&#39;X-Response-Time&#39;, ms + &#39;ms&#39;);
});

// logger

app.use(function *(next){
  var start = new Date;
  yield next;
  var ms = new Date - start;
  console.log(&#39;%s %s - %s&#39;, this.method, this.url, ms);
});

// response

app.use(function *(){
  this.body = &#39;Hello World&#39;;
});

app.listen(3000);</code></pre>
<p>在上方的范例代码中，中间件以此被执行的顺序已经在注释中标记出来。你也可以自己尝试运行一下这个范例，并打印记录下各个环节的输出与耗时。</p>
<p><strong>译者注：</strong> 「级联」这个词许多人也许在 CSS 中听说过，如果你不能理解为什么在这里使用这个词，可以将这种路由结构想象成 LESS 的继承嵌套书写方式：</p>
<pre><code>.middleware1 {
  // (1) do some stuff
  .middleware2 {
    // (2) do some other stuff
    .middleware3 {
      // (3) NO next yield !
      // this.body = &#39;hello world&#39;
    }
    // (4) do some other stuff later
  }
  // (5) do some stuff lastest and return
}</code></pre>
<p>上方的伪代码中标注了中间件的执行顺序，看起来是不是有点像 ruby 执行代码块（block）时 yield 的表现了？也许这能帮助你更好的理解 koa 运作的方式。</p>
<p><strong>译者注：</strong> 更加形象的图可以参考 <a href="https://docs.djangoproject.com/en/1.6/topics/http/middleware/">Django Middleware</a></p>
<p><img src="https://raw.github.com/fengmk2/koa-guide/master/onion.png" alt="onion.png"></p>
<h2 id="-settings-">应用配置（Settings）</h2>
<p>应用的配置是 app 实例的属性。目前来说，Koa 的配置项如下：</p>
<ul>
<li>app.name 应用名称</li>
<li>app.env 执行环境，默认是 <code>NODE_ENV</code> 或者 <code>&quot;development&quot;</code> 字符串</li>
<li>app.proxy 决定了哪些 <code>proxy header</code> 参数会被加到信任列表中</li>
<li>app.subdomainOffset 被忽略的 <code>.subdomains</code> 列表，详见下方 api</li>
<li>app.jsonSpaces 输出 json 时是否自动添加空格充当缩进，详见下方 api</li>
<li>app.outputErrors 是否输出错误堆栈（<code>err.stack</code>）到 <code>stderr</code> [当执行环境是 <code>&quot;test&quot;</code> 的时候为 <code>false</code>]</li>
</ul>
<h2 id="-middleware-">中间件（Middleware）</h2>
<ul>
<li><a href="https://github.com/alexmingoia/koa-router">koa-router</a></li>
<li><a href="https://github.com/koajs/trie-router">trie-router</a></li>
<li><a href="https://github.com/koajs/route">route</a></li>
<li><a href="https://github.com/koajs/basic-auth">basic-auth</a></li>
<li><a href="https://github.com/koajs/etag">etag</a></li>
<li><a href="https://github.com/koajs/compose">compose</a></li>
<li><a href="https://github.com/koajs/static">static</a></li>
<li><a href="https://github.com/koajs/static-cache">static-cache</a></li>
<li><a href="https://github.com/koajs/session">session</a></li>
<li><a href="https://github.com/koajs/compress">compress</a></li>
<li><a href="https://github.com/koajs/csrf">csrf</a></li>
<li><a href="https://github.com/koajs/logger">logger</a></li>
<li><a href="https://github.com/koajs/mount">mount</a></li>
<li><a href="https://github.com/koajs/send">send</a></li>
<li><a href="https://github.com/koajs/error">error</a></li>
</ul>
<h2 id="app-listen-">app.listen(...)</h2>
<p>  一个 Koa 应用跟 HTTP server 不是 1-to-1 关系, 一个或多个 Koa 应用可以被加载到一块
  组成一个更大的包含一个 HTTP server 的应用.</p>
<p>  创建并返回一个 http server, 并且支持传递参数
  <code>Server#listen()</code>. 具体参数可查看 <a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback">nodejs.org</a>. 如下为一个监听 <code>3000</code> 端口的简单应用:</p>
<pre><code class="lang-js">var koa = require(&#39;koa&#39;);
var app = koa();
app.listen(3000);</code></pre>
<p>  方法 <code>app.listen(...)</code> 是一个语法糖, 等价于:</p>
<pre><code class="lang-js">var http = require(&#39;http&#39;);
var koa = require(&#39;koa&#39;);
var app = koa();
http.createServer(app.callback()).listen(3000);</code></pre>
<p>  这样你可以同时支持 HTTP 和 HTTPS, 或在多个地址上使用同一个 app.</p>
<pre><code class="lang-js">var http = require(&#39;http&#39;);
var koa = require(&#39;koa&#39;);
var app = koa();
http.createServer(app.callback()).listen(3000);
http.createServer(app.callback()).listen(3001);</code></pre>
<h2 id="app-callback-">app.callback()</h2>
<p>  返回一个可被 <code>http.createServer()</code> 接受的程序实例，也可以将这个返回函数挂载在一个 Connect/Express 应用中。</p>
<h2 id="app-use-function-">app.use(function)</h2>
<p>  将给定的 function 当做中间件加载到应用中，详见 <a href="#middleware">中间件</a> 章节</p>
<h2 id="app-keys-">app.keys=</h2>
<p> 设置一个签名 Cookie 的密钥。这些参数会被传递给 <a href="https://github.com/jed/keygrip">KeyGrip</a> 如果你想自己生成一个实例，也可以这样：</p>
<pre><code class="lang-js">app.keys = [&#39;im a newer secret&#39;, &#39;i like turtle&#39;];
app.keys = new KeyGrip([&#39;im a newer secret&#39;, &#39;i like turtle&#39;], &#39;sha256&#39;);</code></pre>
<p>  注意，签名密钥只在配置项 <code>signed</code> 参数为真是才会生效：</p>
<pre><code class="lang-js">this.cookies.set(&#39;name&#39;, &#39;tobi&#39;, { signed: true });</code></pre>
<h2 id="-error-handling-">错误处理（Error Handling）</h2>
<p>  除非应用执行环境被配置为 <code>&quot;test&quot;</code>，Koa 都将会将所有错误信息输出到 stderr，和 Connect 一样，你可以自己定义一个「错误事件」来监听 Koa app 中发生的错误：</p>
<pre><code class="lang-js">app.on(&#39;error&#39;, function(err){
  log.error(&#39;server error&#39;, err);
});</code></pre>
<p>  当任何 req 或者 res 中出现的错误无法被回应到客户端时，Koa 会在第二个参数传入这个错误的上下文：</p>
<pre><code class="lang-js">app.on(&#39;error&#39;, function(err, ctx){
  log.error(&#39;server error&#39;, err, ctx);
});</code></pre>
<p>  如果任何错误有可能被回应到客户端，比如当没有新数据写入 socket 时，Koa 会默认返回一个 500 错误，并抛出一个 app 级别的错误到日志处理中间件中。</p>
</div></section><section><div class="content"><h1 id="context">Context</h1>
<p>  Koa 的 Context 把 node 的 request, response 对象包含进一个单独对象, 并提供许多开发 web 应用和 APIs 的有用方法.</p>
<p>  许多访问器和方法直接委托为他们 <code>ctx.request</code> 或 <code>ctx.response</code> 的
  等价方法, 用于访问方便, 有些是完全相同.</p>
<p>  这些操作在 HTTP server 开发中使用如此频繁, 所以在这里实现.
  而不是更高层次框架 这样中间件中就不需要重复实现这些通用的功能.</p>
<p>  <em>每个</em> 请求会创建自己的 <code>Context</code>, 在中间件中作为 receiver 引用, 或通过 <code>this</code> 标示符. 如.</p>
<pre><code class="lang-js">app.use(function *(){
  this; // is the Context
  this.request; // is a koa Request
  this.response; // is a koa Response
});</code></pre>
<h2 id="api">API</h2>
<p>  <code>Context</code> 详细方法和访问器.</p>
<h3 id="ctx-req">ctx.req</h3>
<p>  Node 的 <code>request</code> 对象.</p>
<h3 id="ctx-res">ctx.res</h3>
<p>  Node 的 <code>response</code> 对象.</p>
<p>  Bypassing Koa 的 response handling 是 <strong>not supported</strong>. 避免使用如下 node 属性:</p>
<ul>
<li><code>res.statusCode</code></li>
<li><code>res.writeHead()</code></li>
<li><code>res.write()</code></li>
<li><code>res.end()</code></li>
</ul>
<h3 id="ctx-request">ctx.request</h3>
<p>  koa <code>Request</code> 对象.</p>
<h3 id="ctx-response">ctx.response</h3>
<p>  koa <code>Response</code> 对象.</p>
<h3 id="ctx-app">ctx.app</h3>
<p>  应用实例引用.</p>
<h3 id="ctx-cookies-get-name-options-">ctx.cookies.get(name, [options])</h3>
<p>  获取名为 <code>name</code> 带有 <code>options</code> 的 cookie:</p>
<ul>
<li><code>signed</code> 请求cookie应该是signed</li>
</ul>
<p>注意: koa 使用 <a href="https://github.com/jed/cookies">cookies</a> 模块, options 被直接传递过去.</p>
<h3 id="ctx-cookies-set-name-value-options-">ctx.cookies.set(name, value, [options])</h3>
<p>  设置cookie <code>name</code> 为 <code>value</code> 带有 <code>options</code>:</p>
<ul>
<li><code>signed</code> sign cookie 值</li>
<li><code>expires</code> cookie 过期 <code>Date</code></li>
<li><code>path</code> cookie 路径, 默认 <code>/&#39;</code></li>
<li><code>domain</code> cookie 域名</li>
<li><code>secure</code> secure cookie</li>
<li><code>httpOnly</code> server 才能访问 cookie, 默认 <strong>true</strong> </li>
</ul>
<p>注意: koa 使用 <a href="https://github.com/jed/cookies">cookies</a> 模块, options 被直接传递过去.</p>
<h3 id="ctx-throw-msg-status-">ctx.throw(msg, [status])</h3>
<p>  Helper 方法, 抛出包含 <code>.status</code> 属性的错误, 默认为 <code>500</code>. 该方法让 Koa 能够合适的响应.
  并且支持如下组合:</p>
<pre><code class="lang-js">this.throw(403)
this.throw(&#39;name required&#39;, 400)
this.throw(400, &#39;name required&#39;)
this.throw(&#39;something exploded&#39;)</code></pre>
<p>  例如 <code>this.throw(&#39;name required&#39;, 400)</code> 等价于:</p>
<pre><code class="lang-js">var err = new Error(&#39;name required&#39;);
err.status = 400;
throw err;</code></pre>
<p>  注意这些是 user-level 的错误, 被标记为 <code>err.expose</code>, 即这些消息可以用于 client 响应,
  而不是 error message 的情况, 因为你不想泄露失败细节.</p>
<h2 id="request-">Request 别名</h2>
<p>  如下访问器和别名同 <a href="#request">Request</a> 等价:</p>
<ul>
<li><code>ctx.header</code></li>
<li><code>ctx.method</code></li>
<li><code>ctx.method=</code></li>
<li><code>ctx.url</code></li>
<li><code>ctx.url=</code></li>
<li><code>ctx.path</code></li>
<li><code>ctx.path=</code></li>
<li><code>ctx.query</code></li>
<li><code>ctx.query=</code></li>
<li><code>ctx.querystring</code></li>
<li><code>ctx.querystring=</code></li>
<li><code>ctx.length</code></li>
<li><code>ctx.host</code></li>
<li><code>ctx.host=</code></li>
<li><code>ctx.fresh</code></li>
<li><code>ctx.stale</code></li>
<li><code>ctx.socket</code></li>
<li><code>ctx.protocol</code></li>
<li><code>ctx.secure</code></li>
<li><code>ctx.ip</code></li>
<li><code>ctx.ips</code></li>
<li><code>ctx.subdomains</code></li>
<li><code>ctx.is()</code></li>
<li><code>ctx.accepts()</code></li>
<li><code>ctx.acceptsEncodings()</code></li>
<li><code>ctx.acceptsCharsets()</code></li>
<li><code>ctx.acceptsLanguages()</code></li>
<li><code>ctx.get()</code></li>
</ul>
<h2 id="response-">Response 别名</h2>
<p>  如下访问器和别名同 <a href="#response">Response</a> 等价:</p>
<ul>
<li><code>ctx.body</code></li>
<li><code>ctx.body=</code></li>
<li><code>ctx.status</code></li>
<li><code>ctx.status=</code></li>
<li><code>ctx.length=</code></li>
<li><code>ctx.type</code></li>
<li><code>ctx.type=</code></li>
<li><code>ctx.headerSent</code></li>
<li><code>ctx.redirect()</code></li>
<li><code>ctx.attachment()</code></li>
<li><code>ctx.set()</code></li>
<li><code>ctx.remove()</code></li>
<li><code>ctx.lastModified=</code></li>
<li><code>ctx.etag=</code></li>
</ul>
</div></section><section><div class="content"><h1 id="request">Request</h1>
<p>  Koa <code>Request</code> 对象是 node 普通 request 对象之上的抽象, 提供了日常 HTTP server 中有用的功能.</p>
<h2 id="api">API</h2>
<h3 id="req-header">req.header</h3>
<p>  请求头对象.</p>
<h3 id="req-method">req.method</h3>
<p>  请求方法.</p>
<h3 id="req-method-">req.method=</h3>
<p>  设置请求方法, 实现中间件时非常有用, 例如 <code>methodOverride()</code>.</p>
<h3 id="req-length">req.length</h3>
<p>  将请求的 Content-Length 返回为数字, 或 <code>undefined</code>.</p>
<h3 id="req-url">req.url</h3>
<p>  获取请求 URL.</p>
<h3 id="req-url-">req.url=</h3>
<p>设置请求 URL, 在 rewrites 时有用.</p>
<h3 id="req-path">req.path</h3>
<p>  获取请求 pathname.</p>
<h3 id="req-path-">req.path=</h3>
<p>  设置请求 pathname, 如果有 query-string 则保持不变.</p>
<h3 id="req-querystring">req.querystring</h3>
<p>  获取原始 query string, 不包含 <code>?</code>.</p>
<h3 id="req-querystring-">req.querystring=</h3>
<p>  设置 query string.</p>
<h3 id="req-search">req.search</h3>
<p>  获取原始 query string, 包含 <code>?</code>.</p>
<h3 id="req-search-">req.search=</h3>
<p>  设置 query string.</p>
<h3 id="req-host">req.host</h3>
<p>  获取 host, 不包含端口号. 当 <code>app.proxy</code> 为 <strong>true</strong> 时支持 <code>X-Forwarded-Host</code>, 否者就使用 <code>Host</code>. </p>
<h3 id="req-host-">req.host=</h3>
<p>  设置 <code>Host</code> 头字段.</p>
<h3 id="req-type">req.type</h3>
<p>  获取请求 <code>Content-Type</code> 字段, 不包含参数, 如 &quot;charset&quot;.</p>
<pre><code class="lang-js">var ct = this.type;
// =&gt; &quot;image/png&quot;</code></pre>
<h3 id="req-query">req.query</h3>
<p>  获取解析后的 query-string, 如果没有返回空对象. 注意: 该方法不支持嵌套解析.</p>
<p>  例如 &quot;color=blue&amp;size=small&quot;:</p>
<pre><code class="lang-js">{
  color: &#39;blue&#39;,
  size: &#39;small&#39;
}</code></pre>
<h3 id="req-query-">req.query=</h3>
<p>  根据给定的对象设置 query-string. 注意: 该方法不支持嵌套对象.</p>
<pre><code class="lang-js">this.query = { next: &#39;/login&#39; };</code></pre>
<h3 id="req-fresh">req.fresh</h3>
<p>  检查请求缓存是否是 &quot;fresh&quot; 的, 即内容没有发生变化. 该方法用于在<code>If-None-Match</code> / <code>ETag</code>, <code>If-Modified-Since</code>, <code>Last-Modified</code> 之间进行缓存 negotiation. 这个应该在设置过这些响应 hearder 后会用到.</p>
<pre><code class="lang-js">this.set(&#39;ETag&#39;, &#39;123&#39;);

// cache is ok
if (this.fresh) {
  this.status = 304;
  return;
}

// cache is stale
// fetch new data
this.body = yield db.find(&#39;something&#39;);</code></pre>
<h3 id="req-stale">req.stale</h3>
<p>  相反与 <code>req.fresh</code>.</p>
<h3 id="req-protocol">req.protocol</h3>
<p>  返回请求协议, &quot;https&quot; 或 &quot;http&quot;. 当 <code>app.proxy</code> 为 <strong>true</strong> 时支持 <code>X-Forwarded-Proto</code>.</p>
<h3 id="req-secure">req.secure</h3>
<p>  简化版 <code>this.protocol == &quot;https&quot;</code> 用于检查请求是否通过 TLS 发送.</p>
<h3 id="req-ip">req.ip</h3>
<p>  请求 IP 地址. 当 <code>app.proxy</code> 为 <strong>true</strong> 时支持 <code>X-Forwarded-Proto</code>.</p>
<h3 id="req-ips">req.ips</h3>
<p>  当 <code>X-Forwarded-For</code> 存在并且 <code>app.proxy</code> 开启会返回一个有序(upstream -&gt; downstream)的 ip 数组.
  否则返回空数组.</p>
<h3 id="req-subdomains">req.subdomains</h3>
<p>  以数组形式返回子域名.</p>
<p>  子域名是 host 逗号分隔主域名前面的部分. 默认主域名是 host 的最后两部分. 可以通过设置 <code>app.subdomainOffset</code> 调整.</p>
<p>  例如, 架设域名是 &quot;tobi.ferrets.example.com&quot;:
  如果 <code>app.subdomainOffset</code> 没有设置, this.subdomains 为 <code>[&quot;ferrets&quot;, &quot;tobi&quot;]</code>.
  如果 <code>app.subdomainOffset</code> 设为 3, this.subdomains 为 <code>[&quot;tobi&quot;]</code>.</p>
<h3 id="req-is-type-">req.is(type)</h3>
<p>  检查请求是否包含 &quot;Content-Type&quot; 字段, 并且包含当前已知的 mime &#39;type&#39;.
  如果没有请求 body, 返回 <code>undefined</code>.
  如果没有字段, 或不包含, 返回 <code>false</code>.
  否则返回包含的 content-type.</p>
<pre><code class="lang-js">// With Content-Type: text/html; charset=utf-8
this.is(&#39;html&#39;); // =&gt; &#39;html&#39;
this.is(&#39;text/html&#39;); // =&gt; &#39;text/html&#39;
this.is(&#39;text/*&#39;, &#39;text/html&#39;); // =&gt; &#39;text/html&#39;

// When Content-Type is application/json
this.is(&#39;json&#39;, &#39;urlencoded&#39;); // =&gt; &#39;json&#39;
this.is(&#39;application/json&#39;); // =&gt; &#39;application/json&#39;
this.is(&#39;html&#39;, &#39;application/*&#39;); // =&gt; &#39;application/json&#39;

this.is(&#39;html&#39;); // =&gt; false</code></pre>
<p>  例如, 如果你想确保指定的路由只返回图片.</p>
<pre><code class="lang-js">if (this.is(&#39;image/*&#39;)) {
  // process
} else {
  this.throw(415, &#39;images only!&#39;);
}</code></pre>
<h3 id="req-accepts-types-">req.accepts(types)</h3>
<p>  检查给定的 <code>type(s)</code> 是否 acceptable, 如果是, 则返回最佳的匹配, 否则 <code>false</code>, 
  这时应该响应 406 &quot;Not Acceptable&quot;.</p>
<p>  <code>type</code> 值应该是一个或多个 mime 字符串, 例如 &quot;application/json&quot;, 扩展名如 &quot;json&quot;, 或数组 <code>[&quot;json&quot;, &quot;html&quot;, &quot;text/plain&quot;]</code>.
  如果给定一个 list 或 array, 会返回最佳(<em>best</em>)匹配项.</p>
<p>  如果请求 client 没有发送 <code>Accept</code> header, 会返回第一个 <code>type</code>.</p>
<pre><code class="lang-js">// Accept: text/html
this.accepts(&#39;html&#39;);
// =&gt; &quot;html&quot;

// Accept: text/*, application/json
this.accepts(&#39;html&#39;);
// =&gt; &quot;html&quot;
this.accepts(&#39;text/html&#39;);
// =&gt; &quot;text/html&quot;
this.accepts(&#39;json&#39;, &#39;text&#39;);
// =&gt; &quot;json&quot;
this.accepts(&#39;application/json&#39;);
// =&gt; &quot;application/json&quot;

// Accept: text/*, application/json
this.accepts(&#39;image/png&#39;);
this.accepts(&#39;png&#39;);
// =&gt; undefined

// Accept: text/*;q=.5, application/json
this.accepts([&#39;html&#39;, &#39;json&#39;]);
this.accepts(&#39;html&#39;, &#39;json&#39;);
// =&gt; &quot;json&quot;</code></pre>
<p>  <code>this.accepts()</code> 可以被多次调用, 或使用在 switch.</p>
<pre><code class="lang-js">switch (this.accepts(&#39;json&#39;, &#39;html&#39;, &#39;text&#39;)) {
  case &#39;json&#39;: break;
  case &#39;html&#39;: break;
  case &#39;text&#39;: break;
  default: this.throw(406);
}</code></pre>
<h3 id="req-acceptsencodings-encodings-">req.acceptsEncodings(encodings)</h3>
<p>  检查 <code>encodings</code> 是否被接受, 如果是返回最佳匹配, 否则返回 <code>identity</code>.</p>
<pre><code class="lang-js">// Accept-Encoding: gzip
this.acceptsEncodings(&#39;gzip&#39;, &#39;deflate&#39;);
// =&gt; &quot;gzip&quot;

this.acceptsEncodings([&#39;gzip&#39;, &#39;deflate&#39;]);
// =&gt; &quot;gzip&quot;</code></pre>
<p>  如果没有传递参数, 会返回所有可接受的 encodings 数组.</p>
<pre><code class="lang-js">// Accept-Encoding: gzip, deflate
this.acceptsEncodings();
// =&gt; [&quot;gzip&quot;, &quot;deflate&quot;]</code></pre>
<h3 id="req-acceptscharsets-charsets-">req.acceptsCharsets(charsets)</h3>
<p>  检查 <code>charsets</code> 是否被接受, 如果是返回最佳匹配, 否则 <code>undefined</code>.</p>
<pre><code class="lang-js">// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5
this.acceptsCharsets(&#39;utf-8&#39;, &#39;utf-7&#39;);
// =&gt; &quot;utf-8&quot;

this.acceptsCharsets([&#39;utf-7&#39;, &#39;utf-8&#39;]);
// =&gt; &quot;utf-8&quot;</code></pre>
<p>  如果没有传递参数, 会返回所有可接受 charsets 数组.</p>
<pre><code class="lang-js">// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5
this.acceptsCharsets();
// =&gt; [&quot;utf-8&quot;, &quot;utf-7&quot;, &quot;iso-8859-1&quot;]</code></pre>
<h3 id="req-acceptslanguages-langs-">req.acceptsLanguages(langs)</h3>
<p>  检查 <code>langs</code> 是否被接受, 如果是返回最佳匹配, 否则返回 <code>undefined</code>.</p>
<pre><code class="lang-js">// Accept-Language: en;q=0.8, es, pt
this.acceptsLanguages(&#39;es&#39;, &#39;en&#39;);
// =&gt; &quot;es&quot;

this.acceptsLanguages([&#39;en&#39;, &#39;es&#39;]);
// =&gt; &quot;es&quot;</code></pre>
<p>  如果没有传递参数, 会返回所有可接受的 lang 数组.</p>
<pre><code class="lang-js">// Accept-Language: en;q=0.8, es, pt
this.acceptsLanguages();
// =&gt; [&quot;es&quot;, &quot;pt&quot;, &quot;en&quot;]</code></pre>
</div></section><section><div class="content"><h1 id="response">Response</h1>
<p>  Koa <code>Response</code> 对象是 node 普通 request 对象之上的抽象, 提供了日常 HTTP server 中有用的功能.</p>
<h2 id="api">API</h2>
<h3 id="res-header">res.header</h3>
<p> 响应 header 对象.</p>
<h3 id="res-status">res.status</h3>
<p>返回响应状态. 默认 <code>res.status</code> 没有值, 而不是像 node 的 <code>res.statusCode</code> 默认为 <code>200</code>.</p>
<h3 id="res-status-">res.status=</h3>
<p>使用状态码或不区分大小写的字符串设置响应状态:</p>
<ul>
<li>100 &quot;continue&quot;</li>
<li>101 &quot;switching protocols&quot;</li>
<li>102 &quot;processing&quot;</li>
<li>200 &quot;ok&quot;</li>
<li>201 &quot;created&quot;</li>
<li>202 &quot;accepted&quot;</li>
<li>203 &quot;non-authoritative information&quot;</li>
<li>204 &quot;no content&quot;</li>
<li>205 &quot;reset content&quot;</li>
<li>206 &quot;partial content&quot;</li>
<li>207 &quot;multi-status&quot;</li>
<li>300 &quot;multiple choices&quot;</li>
<li>301 &quot;moved permanently&quot;</li>
<li>302 &quot;moved temporarily&quot;</li>
<li>303 &quot;see other&quot;</li>
<li>304 &quot;not modified&quot;</li>
<li>305 &quot;use proxy&quot;</li>
<li>307 &quot;temporary redirect&quot;</li>
<li>400 &quot;bad request&quot;</li>
<li>401 &quot;unauthorized&quot;</li>
<li>402 &quot;payment required&quot;</li>
<li>403 &quot;forbidden&quot;</li>
<li>404 &quot;not found&quot;</li>
<li>405 &quot;method not allowed&quot;</li>
<li>406 &quot;not acceptable&quot;</li>
<li>407 &quot;proxy authentication required&quot;</li>
<li>408 &quot;request time-out&quot;</li>
<li>409 &quot;conflict&quot;</li>
<li>410 &quot;gone&quot;</li>
<li>411 &quot;length required&quot;</li>
<li>412 &quot;precondition failed&quot;</li>
<li>413 &quot;request entity too large&quot;</li>
<li>414 &quot;request-uri too large&quot;</li>
<li>415 &quot;unsupported media type&quot;</li>
<li>416 &quot;requested range not satisfiable&quot;</li>
<li>417 &quot;expectation failed&quot;</li>
<li>418 &quot;i&#39;m a teapot&quot;</li>
<li>422 &quot;unprocessable entity&quot;</li>
<li>423 &quot;locked&quot;</li>
<li>424 &quot;failed dependency&quot;</li>
<li>425 &quot;unordered collection&quot;</li>
<li>426 &quot;upgrade required&quot;</li>
<li>428 &quot;precondition required&quot;</li>
<li>429 &quot;too many requests&quot;</li>
<li>431 &quot;request header fields too large&quot;</li>
<li>500 &quot;internal server error&quot;</li>
<li>501 &quot;not implemented&quot;</li>
<li>502 &quot;bad gateway&quot;</li>
<li>503 &quot;service unavailable&quot;</li>
<li>504 &quot;gateway time-out&quot;</li>
<li>505 &quot;http version not supported&quot;</li>
<li>506 &quot;variant also negotiates&quot;</li>
<li>507 &quot;insufficient storage&quot;</li>
<li>509 &quot;bandwidth limit exceeded&quot;</li>
<li>510 &quot;not extended&quot;</li>
<li>511 &quot;network authentication required&quot;</li>
</ul>
<p><strong>注意</strong>: 不用担心没法记住这些状态码, 如果设置错误, 会有异常抛出, 并列出该状态码表, 
从而帮助修改.</p>
<h3 id="res-length-">res.length=</h3>
<p>  设置响应 Content-Length.</p>
<h3 id="res-length">res.length</h3>
<p>  如果 Content-Length 存在返回相应数值, 或通过 <code>res.body</code> 计算得出, 否则返回 <code>undefined</code>.</p>
<h3 id="res-body">res.body</h3>
<p>  返回响应内容.</p>
<h3 id="res-body-">res.body=</h3>
<p>设置响应内容为如下值:</p>
<ul>
<li><code>string</code> written</li>
<li><code>Buffer</code> written</li>
<li><code>Stream</code> piped</li>
<li><code>Object</code> json-stringified</li>
<li><p><code>null</code> no content response</p>
<p>如果 <code>res.status</code> 没有设置, Koa 会自动设定 status 为 <code>200</code> 或 <code>204</code>.</p>
</li>
</ul>
<h4 id="string">String</h4>
<p>  Content-Type 默认设置为 text/html 或 text/plain, 两个的编码都是 utf-8. Content-Length 同样会被设置.</p>
<h4 id="buffer">Buffer</h4>
<p>  Content-Type 默认设置为 application/octet-stream, 并设置 Content-Length.</p>
<h4 id="stream">Stream</h4>
<p>  Content-Type 默认设置为 application/octet-stream.</p>
<h4 id="object">Object</h4>
<p>  Content-Type 默认设置为 to application/json.</p>
<h4 id="notes">Notes</h4>
<p>  若想设置 JSON response 格式可以设置 <code>app.jsonSpaces</code>
  配置, 如想要压缩 JSON 结果可以设置:</p>
<pre><code class="lang-js">app.jsonSpaces = 0;</code></pre>
<h3 id="res-get-field-">res.get(field)</h3>
<p>  获取响应头部字段值, <code>field</code> 区分大小写.</p>
<pre><code class="lang-js">var etag = this.get(&#39;ETag&#39;);</code></pre>
<h3 id="res-set-field-value-">res.set(field, value)</h3>
<p>  设置响应头部字段 <code>field</code> 为 <code>value</code>:</p>
<pre><code class="lang-js">this.set(&#39;Cache-Control&#39;, &#39;no-cache&#39;);</code></pre>
<h3 id="res-set-fields-">res.set(fields)</h3>
<p>  使用对象同时设置多个响应头 <code>fields</code></p>
<pre><code class="lang-js">this.set({
  &#39;Etag&#39;: &#39;1234&#39;,
  &#39;Last-Modified&#39;: date
});</code></pre>
<h3 id="res-remove-field-">res.remove(field)</h3>
<p>  删除头部 <code>field</code> 字段.</p>
<h3 id="res-type">res.type</h3>
<p>  获取响应 <code>Content-Type</code> 字段, 不包含参数如 &quot;charset&quot;.</p>
<pre><code class="lang-js">var ct = this.type;
// =&gt; &quot;image/png&quot;</code></pre>
<h3 id="res-type-">res.type=</h3>
<p>  通过 mime 字符串或文件扩展名设置响应 <code>Content-Type</code>.</p>
<pre><code class="lang-js">this.type = &#39;text/plain; charset=utf-8&#39;;
this.type = &#39;image/png&#39;;
this.type = &#39;.png&#39;;
this.type = &#39;png&#39;;</code></pre>
<p>  注意: 当合适的 <code>charset</code> 可以确定, 会自动设置, 例如 <code>res.type = &#39;html&#39;</code>
  会自动设置为 &quot;utf-8&quot;, 但是如果设置完整时, charset 不会自动设定,
  如 <code>res.type = &#39;text/html&#39;</code>.</p>
<h3 id="res-redirect-url-alt-">res.redirect(url, [alt])</h3>
<p>  执行 [302] 重定向到 <code>url</code>.</p>
<p>  字符 &quot;back&quot; 是一种特殊用法, 能提供 Referrer支持, 当没有 Referrer时 使用<code>alt</code> 或 &quot;/&quot;</p>
<pre><code class="lang-js">this.redirect(&#39;back&#39;);
this.redirect(&#39;back&#39;, &#39;/index.html&#39;);
this.redirect(&#39;/login&#39;);
this.redirect(&#39;http://google.com&#39;);</code></pre>
<p>  如果想要修改默认状态 <code>302</code>, 直接在重定向之前或之后设定 status, 如果想修改 body , 需要
  在重定向之后执行. </p>
<pre><code class="lang-js">this.status = 301;
this.redirect(&#39;/cart&#39;);
this.body = &#39;Redirecting to shopping cart&#39;;</code></pre>
<h3 id="res-attachment-filename-">res.attachment([filename])</h3>
<p>  设置 &quot;attachment&quot;  的 <code>Content-Disposition</code> 用于给客户端发送信号, 提示下载. 
  下载文件的名字可以通过参数设置.</p>
<h3 id="res-headersent">res.headerSent</h3>
<p>  检查响应头是否已经发送. 在有错误时检查 client 是否被通知时有用.</p>
<h3 id="res-lastmodified">res.lastModified</h3>
<p>  如果响应头部包含 <code>Last-Modified</code>, 返回 <code>Date</code>.</p>
<h3 id="res-lastmodified-">res.lastModified=</h3>
<p>  将 <code>Last-Modified</code> 头部设置为正确的 UTC string. 可以使用 <code>Date</code> 或 date 字符串设置.</p>
<pre><code class="lang-js">this.response.lastModified = new Date();</code></pre>
<h3 id="res-etag-">res.etag=</h3>
<p>  设置响应的 ETag (包括 wrapped <code>&quot;</code>). 注意没有对应的 <code>res.etag</code> 获取器.</p>
<pre><code class="lang-js">this.response.etag = crypto.createHash(&#39;md5&#39;).update(this.body).digest(&#39;hex&#39;);</code></pre>
</div></section><section><div class="content"><h1 id="guide">Guide</h1>
<p>  这节内容跟 API 无关, 而是中间件开发最佳实践, 应用架构建议等.</p>
<h2 id="-">开发中间件</h2>
<p>  Koa 中间件是返回 <code>GeneratorFunction</code> 的方法, 并接受其他的中间件. 当某个中间件被 &quot;upstream&quot; 中间件执行时, 它必须手动 <code>yield</code>
  &quot;downstream&quot; 中间件</p>
<p>  例如你想记录 request 传递经过 Koa 的时间, 可以开发一个添加 <code>X-Response-Time</code> 头字段的中间件.</p>
<pre><code class="lang-js">function *responseTime(next){
  var start = new Date;
  yield next;
  var ms = new Date - start;
  this.set(&#39;X-Response-Time&#39;, ms + &#39;ms&#39;);
}

app.use(responseTime);</code></pre>
<p>  如下是一个等价的 inline 中间件:</p>
<pre><code class="lang-js">app.use(function *(next){
  var start = new Date;
  yield next;
  var ms = new Date - start;
  this.set(&#39;X-Response-Time&#39;, ms + &#39;ms&#39;);
});</code></pre>
<p>  如果你是一个前端工程师, 可以把所有 <code>yield next;</code> 之前的代码看做 &quot;capture&quot; 阶段, 把之后的代码看做 &quot;bubble&quot; 阶段. 
  如下 gif 展示了 ES6 generators 如何让我们合理的使用 stack flow 实现 request and response flows:</p>
<p><img src="https://i.cloudup.com/N7L5UakJo0.gif" alt="koa middleware"></p>
<ol>
<li>创建 date 记录花费时间</li>
<li>将控制 Yield 到下一个 middleware</li>
<li>创建另外 date 记录响应时间</li>
<li>将控制 Yield 到下一个 middleware</li>
<li>立刻 Yield 控制, 因为 <code>contentLength</code> 只对 response 起作用</li>
<li>将 upstream Yield 到 Koa 的 空middleware.</li>
<li>如果请求路径不是 &quot;/&quot;, 则跳过设置 body.</li>
<li>设置响应为 &quot;Hello World&quot;</li>
<li>如果有 body 则设置 <code>Content-Length</code></li>
<li>设置头部字段</li>
<li>输出log</li>
<li>发送响应前设置 <code>X-Response-Time</code> 头字段</li>
<li>转会 Koa, Koa负责发送 response</li>
</ol>
<p>注意最后的中间件 (step <strong>6</strong>) yields, 看起来没有转给任何东西, 但实际上他转给了 Koa 的空 generator. 这是为了保证所有
的中间件遵循相同的 API, 可以在其他中间件前边或后边使用. 如果你删掉最深 &quot;downstream&quot; 中间件的 <code>yield next;</code> 所有的功能
都还 OK, 但是不在遵循这个行为.</p>
<p> 例如如下代码也不会出错:</p>
<pre><code class="lang-js">app.use(function *response(){
  if (&#39;/&#39; != this.url) return;
  this.body = &#39;Hello World&#39;;
});</code></pre>
<p>接下来是中间件开发最佳实践</p>
<h2 id="-">中间件最佳实践</h2>
<p>  这个环节介绍了中间件开发最佳实践相关内容: 可接受的选项, 给中间件命名有利于调试, 及其他.</p>
<h3 id="-">中间件选项</h3>
<p>  在开发中间件时遵循惯例是非常重要的: 使用接受参数的方法 wrapping 中间件, 这样用户可以扩展功能.
  即使你的中间件不接受选项, 保持所有事情一致也是最好的选择.</p>
<p>  如下是一个 <code>logger</code> 中间件, 接受 <code>format</code> 字符串, 用于自定义格式, 最后返回中间件.</p>
<pre><code class="lang-js">function logger(format){
  format = format || &#39;:method &quot;:url&quot;&#39;;

  return function *(next){
    var str = format
      .replace(&#39;:method&#39;, this.method)
      .replace(&#39;:url&#39;, this.url);

    console.log(str);

    yield next;
  }
}

app.use(logger());
app.use(logger(&#39;:method :url&#39;));</code></pre>
<h3 id="-">给中间件命名</h3>
<p>  中间件命名不是强制的, 但如果中间件有名字, 在调试时会非常有帮助.</p>
<pre><code class="lang-js">function logger(format){
  return function *logger(next){

  }
}</code></pre>
<h3 id="-">将多个中间件组合为一个</h3>
<p>  有时候你需要将多个中间件组合成一个, 从而方便重用或 exporting. 这时你可以用 <code>.call(this, next)</code> 将他们连起来, 然后将 yield 这个 chain 的方法返回.</p>
<pre><code class="lang-js">function *random(next){
  if (&#39;/random&#39; == this.path) {
    this.body = Math.floor(Math.random()*10);
  } else {
    yield next;
  }
};

function *backwords(next) {
  if (&#39;/backwords&#39; == this.path) {
    this.body = &#39;sdrowkcab&#39;;
  } else {
    yield next;
  }
}

function *pi(next){
  if (&#39;/pi&#39; == this.path) {
    this.body = String(Math.PI);
  } else {
    yield next;
  }
}

function *all(next) {
  yield random.call(this, backwords.call(this, pi.call(this, next)));
}

app.use(all);</code></pre>
<p>  Koa 内部 使用 koa-compose 创建和调度中间件栈. <a href="https://github.com/koajs/compose">koa-compose</a> 内部就是这样实现的.</p>
<h3 id="-">响应中间件</h3>
<p>  如果中间件用于响应请求, 需要跳过 downstream 的中间件可以直接省略 <code>yield next</code>. 通常路由中间件就是这样的, 而且在所有中间件里都可以省略.
  例如下面的例子会响应 &quot;two&quot;, 但是三个都被执行了, 所以在 downstream &quot;three&quot; 中间件里就有可能修改响应结果.</p>
<pre><code class="lang-js">app.use(function *(next){
  console.log(&#39;&gt;&gt; one&#39;);
  yield next;
  console.log(&#39;&lt;&lt; one&#39;);
});

app.use(function *(next){
  console.log(&#39;&gt;&gt; two&#39;);
  this.body = &#39;two&#39;;
  yield next;
  console.log(&#39;&lt;&lt; two&#39;);
});

app.use(function *(next){
  console.log(&#39;&gt;&gt; three&#39;);
  yield next;
  console.log(&#39;&lt;&lt; three&#39;);
});</code></pre>
<p>  The following configuration omits <code>yield next</code> in the second middleware, and will still respond
  with &quot;two&quot;, however the third (and any other downstream middleware) will be ignored:
  在下面的例子中第二个中间件省略了 <code>yield next</code>, 最终响应结果还是 &quot;two&quot;, 但是第三个(以后后面所有的 downstream 中间件)中间件被忽略了.</p>
<pre><code class="lang-js">app.use(function *(next){
  console.log(&#39;&gt;&gt; one&#39;);
  yield next;
  console.log(&#39;&lt;&lt; one&#39;);
});

app.use(function *(next){
  console.log(&#39;&gt;&gt; two&#39;);
  this.body = &#39;two&#39;;
  console.log(&#39;&lt;&lt; two&#39;);
});

app.use(function *(next){
  console.log(&#39;&gt;&gt; three&#39;);
  yield next;
  console.log(&#39;&lt;&lt; three&#39;);
});</code></pre>
<p>  当最深的中间件执行 <code>yield next;</code>, 它实际上是 yield 的空方法, 这样可以保证 stack 中所有地方的中间件可以正常 compose.</p>
<h2 id="-">异步操作</h2>
<p>  <a href="https://github.com/visionmedia/co">Co</a> 构成了 Koa generator 委托的基石. 让我们可以写非阻塞的顺序代码.
  例如如下代码. 读取 <code>./docs</code> 中的所有文件名, 并读取所有 markdown 的内容, 连接后赋给 body, 这所有的异步操作都是使用
  顺序代码实现的.</p>
<pre><code class="lang-js">var fs = require(&#39;co-fs&#39;);

app.use(function *(){
  var paths = yield fs.readdir(&#39;docs&#39;);

  var files = yield paths.map(function(path){
    return fs.readFile(&#39;docs/&#39; + path, &#39;utf8&#39;);
  });

  this.type = &#39;markdown&#39;;
  this.body = files.join(&#39;&#39;);
});</code></pre>
<h2 id="-koa">调试 Koa</h2>
<p>Koa 和许多相关的库都支持 <strong>DEBUG</strong> 环境变量. 这是通过 <a href="https://github.com/visionmedia/debug">debug</a> 实现的, debug 提供简单的条件 logging.</p>
<p>  例如, 如果想查看所有 koa 调试信息, 设置环境变量为 <code>DEBUG=koa*</code>, 这样在程序启动的时候, 可以看到所有使用的中间件列表.</p>
<pre><code>$ DEBUG=koa* node --harmony examples/simple
  koa:application use responseTime +0ms
  koa:application use logger +4ms
  koa:application use contentLength +0ms
  koa:application use notfound +0ms
  koa:application use response +0ms
  koa:application listen +0ms</code></pre>
<p>  虽然 JavaScript 不允许动态定义方法名, 但是你可以将中间件的名字设置为 <code>._name</code>.
  这在你无法修改中间件名字时非常有用如:</p>
<pre><code class="lang-js">var path = require(&#39;path&#39;);
var static = require(&#39;koa-static&#39;);

var publicFiles = static(path.join(__dirname, &#39;public&#39;));
publicFiles._name = &#39;static /public&#39;;

app.use(publicFiles);</code></pre>
<p>  现在, 在调试模式你不仅可以看到 &quot;static&quot;, 还能:</p>
<pre><code>  koa:application use static /public +0ms</code></pre>
</div></section><section><div class="content"><h1 id="links">相关链接</h1><p>相关社区, 可以发现Koa第三方中间件, 完整可运行例子, 简明的指导,以及更多.
如果发现问题可以在IRC上提出讨论.
</p><ul><li><a href="https://github.com/koajs">GitHub organization</a></li><li><a href="https://github.com/koajs/koa">GitHub repository</a></li><li><a href="https://github.com/koajs/examples">Examples</a></li><li><a href="https://github.com/koajs/koa/wiki">Middleware</a></li><li><a href="https://github.com/koajs/koa/wiki">Wiki</a></li><li><a href="https://plus.google.com/communities/101845768320796750641">G+ Community</a></li><li><a href="https://groups.google.com/forum/#!forum/koajs">Mailing list</a></li><li><a href="https://github.com/koajs/koa/blob/master/docs/guide.md">Guide</a></li><li><a href="https://github.com/koajs/koa/blob/master/docs/faq.md">FAQ</a></li><li><a href="http://koajs.com/">Koajs.com</a></li><li><a href="https://sourcegraph.com/koajs">sourcegraph koajs</a></li><li><a href="https://npmjs.org/package/koa">NPM koa</a></li><li><a href="http://koajs.cn/">Koajs.cn</a></li><li><strong>#koajs</strong> on freenode</li></ul></div></section><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-46116808-3', 'rednode.cn');
ga('send', 'pageview');</script></body></html>