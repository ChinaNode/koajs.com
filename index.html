<!DOCTYPE html><html><head><title>Koa - 下一代 Node.js web 框架</title><link rel="stylesheet" href="public/style.css"><link rel="stylesheet" href="public/icons/css/slate.css"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Italiana&amp;subset=latin"><meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta charset="utf8"><meta name="keywords" content="Koa, Node, 框架, generator"><meta name="description" content="下一代 Node.js web 框架"></head><body><section id="top"><div id="menu"><a id="toggle" href="#"><i class="icon-menu"></i></a><ul><li><a href="#introduction">Introduction</a></li><li><a href="#application">Application</a></li><li><a href="#context">Context</a></li><li><a href="#request">Request</a></li><li><a href="#response">Response</a></li><li><a href="#links">Links</a></li></ul></div><div id="heading"><div id="logo">Koa</div><div id="tagline">Koa，下一代 Node.js web 框架</div></div></section><section><div class="content"><h1 id="introduction">简介</h1><p>由 Express 原班人马打造的 koa，致力于成为一个更小、更健壮、更富有表现力的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升常用错误处理效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。
</p></div></section><section><div class="content"><h1 id="-"> </h1>
<h3 id="-koa">安装 koa</h3>
<p>koa 依赖支持 generator 的 Node 环境，准确来说，是 <code>node &gt;= 0.11.9</code> 的环境。</p>
<pre><code>$ npm install koa</code></pre>
<p>安装完成后，应确保使用 <code>$ node app.js --harmony</code> 即，harmony 模式运行程序。</p>
<p>为了方便，可以将 <code>node</code> 设置为默认启动 harmony 模式的别名：</p>
<pre><code>alias node=&#39;node --harmony&#39;</code></pre>
<hr>
<h3 id="-application-">应用（Application）</h3>
<p>一个 Koa Application（以下简称 app）由一系列 generator 中间件组成。按照编码顺序在栈内依次执行，从这个角度来看，Koa app 和其他中间件系统（比如 Ruby Rack 或者 Connect/Express ）没有什么太大差别，不过，从另一个层面来看，Koa 提供了一种基于底层中间件编写「语法糖」的设计思路，这让设计中间件变得更简单有趣。</p>
<p>在这些中间件中，有负责内容协商（content-negotation）、缓存控制（cache freshness）、反向代理（proxy support）与重定向等等功能的常用中间件（详见 <a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6middleware">中间件</a> 章节），但如前所述， Koa 内核并不会打包这些中间件，让我们先来看看 Koa 极其简单的 Hello World 应用程序：</p>
<pre><code class="lang-javascript">var koa = require(&#39;koa&#39;);
var app = koa();

app.use(function *(){
  this.body = &#39;Hello World&#39;;
});

app.listen(3000);</code></pre>
<p><strong>译者注：</strong> 与普通的 function 不同，generator functions 以 <code>function*</code> 声明。以这种关键词声明的函数支持 <code>yield</code></p>
<hr>
<h3 id="-cascading-">编写级联代码（Cascading）</h3>
<p>Koa 中间件以一种非常传统的方式级联起来，你可能会非常熟悉这种写法。</p>
<p>在以往的 Node 开发中，频繁使用回调不太便于展示复杂的代码逻辑，在 Koa 中，我们可以写出真正具有表现力的中间件。与 Connect 实现中间件的方法相对比，Koa 的做法不是简单的将控制权依次移交给一个又一个的中间件直到程序结束，Koa 执行代码的方式有点像回形针，用户请求通过中间件，遇到 <code>yield next</code> 关键字时，会被传递到下一个符合请求的路由（downstream），在 <code>yield next</code> 捕获不到下一个中间件时，逆序返回继续执行代码（upstream）。</p>
<p>下边这个例子展现了使用这一特殊方法书写的 Hello World 范例：一开始，用户的请求通过 x-response-time 中间件和 logging 中间件，这两个中间件记录了一些请求细节，然后「穿过」 response 中间件一次，最终结束请求，返回 「Hello World」。</p>
<p>当程序运行到 <code>yield next</code> 时，代码流会暂停执行这个中间件的剩余代码，转而切换到下一个被定义的中间件执行代码，这样切换控制权的方式，被称为
downstream，当没有下一个中间件执行 downstream 的时候，代码将会逆序执行。</p>
<pre><code class="lang-javascript">var koa = require(&#39;koa&#39;);
var app = koa();

// x-response-time
app.use(function *(next){
  // (1) 进入路由
  var start = new Date;
  yield next;
  // (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间
  var ms = new Date - start;
  this.set(&#39;X-Response-Time&#39;, ms + &#39;ms&#39;);
  // (6) 返回 this.body
});

// logger
app.use(function *(next){
  // (2) 进入 logger 中间件
  var start = new Date;
  yield next;
  // (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间
  var ms = new Date - start;
  console.log(&#39;%s %s - %s&#39;, this.method, this.url, ms);
});

// response
app.use(function *(){
  // (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream
  this.body = &#39;Hello World&#39;;
});

app.listen(3000);</code></pre>
<p>在上方的范例代码中，中间件以此被执行的顺序已经在注释中标记出来。你也可以自己尝试运行一下这个范例，并打印记录下各个环节的输出与耗时。</p>
<p><strong>译者注：</strong> 「级联」这个词许多人也许在 CSS 中听说过，如果你不能理解为什么在这里使用这个词，可以将这种路由结构想象成 LESS 的继承嵌套书写方式：</p>
<pre><code>.middleware1 {
  // (1) do some stuff
  .middleware2 {
    // (2) do some other stuff
    .middleware3 {
      // (3) NO next yield !
      // this.body = &#39;hello world&#39;
    }
    // (4) do some other stuff later
  }
  // (5) do some stuff lastest and return
}</code></pre>
<p>上方的伪代码中标注了中间件的执行顺序，看起来是不是有点像 ruby 执行代码块（block）时 yield 的表现了？也许这能帮助你更好的理解 koa 运作的方式。</p>
<p><strong>译者注：</strong> 更加形象的图可以参考 <a href="https://docs.djangoproject.com/en/1.6/topics/http/middleware/">Django Middleware</a></p>
<p><img src="https://raw.github.com/fengmk2/koa-guide/master/onion.png" alt="onion.png"></p>
<hr>
<h3 id="-settings-">应用配置（Settings）</h3>
<p>应用的配置是 app 实例的属性。目前来说，Koa 的配置项如下：</p>
<ul>
<li>app.name 应用名称</li>
<li>app.env 执行环境，默认是 <code>NODE_ENV</code> 或者 <code>&quot;development&quot;</code> 字符串</li>
<li>app.proxy 决定了哪些 <code>proxy header</code> 参数会被加到信任列表中</li>
<li>app.subdomainOffset 被忽略的 <code>.subdomains</code> 列表，详见下方 api</li>
<li>app.jsonSpaces 输出 json 时是否自动添加空格充当缩进，详见下方 api</li>
<li>app.outputErrors 是否输出错误堆栈（<code>err.stack</code>）到 <code>stderr</code> [当执行环境是 <code>&quot;test&quot;</code> 的时候为 <code>false</code>]</li>
</ul>
<hr>
<h3 id="-middleware-">中间件（Middleware）</h3>
<ul>
<li><a href="https://github.com/alexmingoia/koa-router">koa-router</a></li>
<li><a href="https://github.com/koajs/trie-router">trie-router</a></li>
<li><a href="https://github.com/koajs/route">route</a></li>
<li><a href="https://github.com/koajs/basic-auth">basic-auth</a></li>
<li><a href="https://github.com/koajs/etag">etag</a></li>
<li><a href="https://github.com/koajs/compose">compose</a></li>
<li><a href="https://github.com/koajs/static">static</a></li>
<li><a href="https://github.com/koajs/static-cache">static-cache</a></li>
<li><a href="https://github.com/koajs/session">session</a></li>
<li><a href="https://github.com/koajs/compress">compress</a></li>
<li><a href="https://github.com/koajs/csrf">csrf</a></li>
<li><a href="https://github.com/koajs/logger">logger</a></li>
<li><a href="https://github.com/koajs/mount">mount</a></li>
<li><a href="https://github.com/koajs/send">send</a></li>
<li><a href="https://github.com/koajs/error">error</a></li>
</ul>
<hr>
<h3 id="-">常用方法</h3>
<h4 id="app-listen-">app.listen(...)</h4>
<p>用于启动一个服务的快捷方法，以下范例代码在 3000 端口启动了一个空服务：</p>
<pre><code class="lang-javascript">var koa = require(&#39;koa&#39;);
var app = koa();
app.listen(3000);</code></pre>
<p>app.listen 是 http.createServer 的简单包装，它实际上这样运行：</p>
<pre><code class="lang-javascript">http.createServer(app.callback()).listen(3000);</code></pre>
<p>如果有需要，你可以在多个端口上启动一个 app，比如同时支持 HTTP 和 HTTPS：</p>
<pre><code class="lang-javascript">http.createServer(app.callback()).listen(3000);
http.createServer(app.callback()).listen(3001);</code></pre>
<h4 id="app-callback-">app.callback()</h4>
<p>返回一个可被 <code>http.createServer()</code> 接受的程序实例，也可以将这个返回函数挂载在一个 Connect/Express 应用中。</p>
<h4 id="app-use-function-">app.use(function)</h4>
<p>将给定的 function 当做中间件加载到应用中，详见 <a href="#middleware">中间件</a> 章节</p>
<h4 id="app-keys-">app.keys=</h4>
<p>设置一个签名 Cookie 的密钥。这些参数会被传递给 <a href="https://github.com/jed/keygrip">KeyGrip</a> 如果你想自己生成一个实例，也可以这样：</p>
<pre><code class="lang-javascript">app.keys = [&#39;im a newer secret&#39;, &#39;i like turtle&#39;];
app.keys = new KeyGrip([&#39;im a newer secret&#39;, &#39;i like turtle&#39;], &#39;sha256&#39;);</code></pre>
<p>注意，签名密钥只在配置项 <code>signed</code> 参数为真是才会生效：</p>
<pre><code class="lang-javascript">this.cookies.set(&#39;name&#39;, &#39;tobi&#39;, { signed: true });</code></pre>
<h3 id="-error-handling-">错误处理（Error Handling）</h3>
<p>除非应用执行环境被配置为 <code>&quot;test&quot;</code>，Koa 都将会将所有错误信息输出到 stderr，和 Connect 一样，你可以自己定义一个「错误事件」来监听 Koa app 中发生的错误：</p>
<pre><code class="lang-javascript">app.on(&#39;error&#39;, function(err){
  log.error(&#39;server error&#39;, err);
});</code></pre>
<p>当任何 req 或者 res 中出现的错误无法被回应到客户端时，Koa 会在第二个参数传入这个错误的上下文：</p>
<pre><code class="lang-javascript">app.on(&#39;error&#39;, function(err, ctx){
  log.error(&#39;server error&#39;, err, ctx);
});</code></pre>
<p>如果任何错误有可能被回应到客户端，比如当没有新数据写入 socket 时，Koa 会默认返回一个 500 错误，并抛出一个 app 级别的错误到日志处理中间件中。</p>
<hr>
<h3 id="-context-">应用上下文（Context）</h3>
<p>Koa 的上下文封装了 request 与 response 对象至一个对象中，并提供了一些帮助开发者编写业务逻辑的方法。为了方便，你可以在 <code>ctx.request</code> 和 <code>ctx.response</code> 中访问到这些方法。</p>
<p>每一个请求都会创建一段上下文。在控制业务逻辑的中间件中，上下文被寄存在 <code>this</code> 对象中：</p>
<pre><code class="lang-javascript">app.use(function *(){
  this; // 上下文对象
  this.request; // Request 对象
  this.response; // Response 对象
});</code></pre>
<h4 id="request-">Request 对象</h4>
<p>ctx.request 对象包括以下属性和别名方法，详见 <a href="#request">Request</a> 章节</p>
<ul>
<li>ctx.header</li>
<li>ctx.method</li>
<li>ctx.method=</li>
<li>ctx.url</li>
<li>ctx.url=</li>
<li>ctx.path</li>
<li>ctx.path=</li>
<li>ctx.query</li>
<li>ctx.query=</li>
<li>ctx.querystring</li>
<li>ctx.querystring=</li>
<li>ctx.length</li>
<li>ctx.host</li>
<li>ctx.fresh</li>
<li>ctx.stale</li>
<li>ctx.socket</li>
<li>ctx.protocol</li>
<li>ctx.secure</li>
<li>ctx.ip</li>
<li>ctx.ips</li>
<li>ctx.subdomains</li>
<li>ctx.is()</li>
<li>ctx.accepts()</li>
<li>ctx.acceptsEncodings()</li>
<li>ctx.acceptsCharsets()</li>
<li>ctx.acceptsLanguages()</li>
<li>ctx.get()</li>
</ul>
<h4 id="response-">Response 对象</h4>
<p>ctx.response 对象包括以下属性和别名方法，详见 <a href="#response">Response</a> 章节</p>
<ul>
<li>ctx.body</li>
<li>ctx.body=</li>
<li>ctx.status</li>
<li>ctx.status=</li>
<li>ctx.length=</li>
<li>ctx.type</li>
<li>ctx.type=</li>
<li>ctx.headerSent</li>
<li>ctx.redirect()</li>
<li>ctx.attachment()</li>
<li>ctx.set()</li>
<li>ctx.remove()</li>
<li>ctx.lastModified=</li>
<li>ctx.etag=</li>
</ul>
<h4 id="-api">上下文对象中的其他 API</h4>
<ul>
<li>ctx.req: Node.js 中的 request 对象</li>
<li>ctx.res: Node.js 中的 response 对象</li>
<li>ctx.app: app 实例</li>
<li>ctx.cookies.get(name, [options]) 对于给定的 name ，返回响应的 cookie<ul>
<li>options<ul>
<li><code>signed</code> [boolean]</li>
</ul>
</li>
</ul>
</li>
<li>ctx.cookies.set(name, value, [options]) 对于给定的参数，设置一个新 cookie<ul>
<li>options<ul>
<li><code>signed</code> [boolean]</li>
<li><code>expires</code> [date]</li>
<li><code>path</code> [string] 默认为 <code>&#39;/&#39;</code></li>
<li><code>domain</code> [string]</li>
<li><code>secure</code> [boolean]</li>
<li><code>httpOnly</code> [boolean] 默认为 <code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>ctx.throw(msg, [status]) 抛出常规错误的辅助方法，默认 status 为 500。</li>
</ul>
<p>以下几种写法都有效：</p>
<pre><code class="lang-javascript">this.throw(403)
this.throw(&#39;name required&#39;, 400)
this.throw(400, &#39;name required&#39;)
this.throw(&#39;something exploded&#39;)</code></pre>
<p>实际上，<code>this.throw(&#39;name required&#39;, 400)</code> 是此代码片段的简写方法：</p>
<pre><code class="lang-javascript">var err = new Error(&#39;name required&#39;);
err.status = 400;
throw err;</code></pre>
<p>需要注意的是，<code>ctx.throw</code> 创建的错误，均为用户级别错误（标记为err.expose），会被返回到客户端。</p>
<hr>
<h3 id="request">Request</h3>
<p>ctx.request 对象是对 Node 原生请求对象的抽象包装，提供了一些非常有用的方法。</p>
<p>详细的 Request 对象 API 如下：</p>
<h4 id="req-header">req.header</h4>
<p>返回请求头</p>
<h4 id="req-method">req.method</h4>
<p>返回请求方法</p>
<h4 id="req-method-">req.method=</h4>
<p>设置 req.method ，用于实现输入 <code>methodOverride()</code> 的中间件</p>
<h4 id="req-length">req.length</h4>
<p>返回 req 对象的 <code>Content-Length</code> (Number)</p>
<h4 id="req-url">req.url</h4>
<p>返回请求 url</p>
<h4 id="req-url-">req.url=</h4>
<p>设置请求 url，用于进行 url 重写</p>
<h4 id="req-path">req.path</h4>
<p>返回请求 pathname</p>
<h4 id="req-path-">req.path=</h4>
<p>设置请求 pathname，如果原有 url 存在查询字符串，则保留这些查询。</p>
<h4 id="req-querystring">req.querystring</h4>
<p>返回 url 中的查询字符串，去除了头部的 <code>&#39;?&#39;</code></p>
<h4 id="req-querystring-">req.querystring=</h4>
<p>设置查询字符串，不包含 <code>&#39;?&#39;</code></p>
<h4 id="req-search">req.search</h4>
<p>返回 url 中的查询字符串，包含了头部的 <code>&#39;?&#39;</code></p>
<h4 id="req-search-">req.search=</h4>
<p>设置查询字符串，包含 <code>&#39;?&#39;</code></p>
<h4 id="req-host">req.host</h4>
<p>返回请求主机名，不包含端口；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-Host</code>。</p>
<h4 id="req-type">req.type</h4>
<p>返回 req 对象的 <code>Content-Type</code>，不包括 <code>charset</code> 属性，范例代码：</p>
<pre><code class="lang-javascript">var ct = this.type;
// =&gt; &quot;image/png&quot;</code></pre>
<h4 id="req-query">req.query</h4>
<p>返回经过解析的查询字符串，类似 Express 中的 req.query，当不存在查询字符串时，返回空对象。</p>
<p>当 url 包含查询字符串 <code>&quot;color=blue&amp;size=small&quot;</code> 时，返回如下：</p>
<pre><code class="lang-javascript">{
  color: &#39;blue&#39;,
  size: &#39;small&#39;
}</code></pre>
<h4 id="req-query-">req.query=</h4>
<p>设置给定的对象为查询对象。范例代码如下：</p>
<pre><code class="lang-javascript">this.query = { next: &#39;/login&#39; };</code></pre>
<h4 id="req-fresh">req.fresh</h4>
<p>检查客户端请求的缓存是否是最新。当缓存为最新时，可编写业务逻辑直接返回 <code>304</code>，范例代码如下：</p>
<pre><code class="lang-javascript">this.set(&#39;ETag&#39;, &#39;123&#39;);

// 当客户端缓存是最新时
if (this.fresh) {
  this.status = 304;
  return;
}

// 当客户端缓存已过期时，返回最新的数据
this.body = yield db.find(&#39;something&#39;);</code></pre>
<h4 id="req-stale">req.stale</h4>
<p>与 req.fresh 返回的结果正好相反</p>
<h4 id="req-protocol">req.protocol</h4>
<p>返回请求协议名，如 <code>&quot;https&quot;</code> 或者 <code>&quot;http&quot;</code>；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-Proto</code>。</p>
<h4 id="req-secure">req.secure</h4>
<p>判断请求协议是否为 HTTPS 的快捷方法，等同于 <code>this.protocol == &quot;https&quot;</code></p>
<h4 id="req-ip">req.ip</h4>
<p>返回请求IP；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-For</code>。</p>
<h4 id="req-ips">req.ips</h4>
<p>返回请求IP列表，仅当 <code>app.proxy</code> 设置为 <code>true</code> ，并存在 <code>X-Forwarded-For</code> 列表时，否则返回空数组。</p>
<h4 id="req-subdomains">req.subdomains</h4>
<p>返回请求对象中的子域名数组。子域名数组会自动由请求域名字符串中的 <code>.</code> 分割开，在没有设置自定义的 <code>app.subdomainOffset</code> 参数时，默认返回根域名之前的所有子域名数组。</p>
<p>例如，当请求域名为 <code>&quot;tobi.ferrets.example.com&quot;</code> 时候，返回 <code>[&quot;ferrets&quot;, &quot;tobi&quot;]</code>，数组顺序是子代域名在前，孙代域名在后。</p>
<p>此例中，如果设置了自定义的 <code>app.subdomainOffset</code> 为 <code>3</code>，将忽略三级域名，返回 <code>[&quot;tobi&quot;]</code>。</p>
<h4 id="req-is-type-">req.is(type)</h4>
<p>判断请求对象中 <code>Content-Type</code> 是否为给定 type 的快捷方法，如果不存在 <code>request.body</code>，将返回 <code>undefined</code>，如果没有符合的类型，返回 <code>false</code>，除此之外，返回匹配的类型字符串。</p>
<pre><code class="lang-javascript">// 客户端 Content-Type: text/html; charset=utf-8
this.is(&#39;html&#39;); // =&gt; &#39;html&#39;
this.is(&#39;text/html&#39;); // =&gt; &#39;text/html&#39;
this.is(&#39;text/*&#39;, &#39;text/html&#39;); // =&gt; &#39;text/html&#39;

// 客户端 Content-Type 为 application/json 时：
this.is(&#39;json&#39;, &#39;urlencoded&#39;); // =&gt; &#39;json&#39;
this.is(&#39;application/json&#39;); // =&gt; &#39;application/json&#39;
this.is(&#39;html&#39;, &#39;application/*&#39;); // =&gt; &#39;application/json&#39;

this.is(&#39;html&#39;); // =&gt; false</code></pre>
<p>又如，下方的代码使用 <code>req.is(type)</code>，仅当请求类型为图片时才进行操作：</p>
<pre><code class="lang-javascript">if (this.is(&#39;image/*&#39;)) {
  // process
} else {
  this.throw(415, &#39;images only!&#39;);
}</code></pre>
<h4 id="req-accepts-type-">req.accepts(type)</h4>
<p>判断请求对象中 <code>Accept</code> 是否为给定 type 的快捷方法，当匹配到符合的类型时，返回最匹配的类型，否则返回 <code>false</code>（此时服务器端应当返回 406 &quot;Not Acceptable&quot; ），传入参数可以是字符串或者数组。</p>
<pre><code class="lang-javascript">// Accept: text/html
this.accepts(&#39;html&#39;);
// =&gt; &quot;html&quot;

// Accept: text/*, application/json
this.accepts(&#39;html&#39;);
// =&gt; &quot;html&quot;
this.accepts(&#39;text/html&#39;);
// =&gt; &quot;text/html&quot;
this.accepts(&#39;json&#39;, &#39;text&#39;);
// =&gt; &quot;json&quot;
this.accepts(&#39;application/json&#39;);
// =&gt; &quot;application/json&quot;

// Accept: text/*, application/json
this.accepts(&#39;image/png&#39;);
this.accepts(&#39;png&#39;);
// =&gt; undefined

// Accept: text/*;q=.5, application/json
this.accepts([&#39;html&#39;, &#39;json&#39;]);
this.accepts(&#39;html&#39;, &#39;json&#39;);
// =&gt; &quot;json&quot;</code></pre>
<p>注意，当请求头中不包含 Accept 属性时，给定的第一个 type 将会被返回。</p>
<h4 id="req-acceptsencodings-encodings-">req.acceptsEncodings(encodings)</h4>
<p>判断客户端是否接受给定的编码方式的快捷方法，当有传入参数时，返回最应当返回的一种编码方式。</p>
<pre><code class="lang-javascript">// Accept-Encoding: gzip
this.acceptsEncodings(&#39;gzip&#39;, &#39;deflate&#39;);
// =&gt; &quot;gzip&quot;

this.acceptsEncodings([&#39;gzip&#39;, &#39;deflate&#39;]);
// =&gt; &quot;gzip&quot;</code></pre>
<p>当没有传入参数时，返回客户端的请求数组：</p>
<pre><code class="lang-javascript">// Accept-Encoding: gzip, deflate
this.acceptsEncodings();
// =&gt; [&quot;gzip&quot;, &quot;deflate&quot;]</code></pre>
<h4 id="req-acceptscharsets-charsets-">req.acceptsCharsets(charsets)</h4>
<p>使用方法同 req.acceptsEncodings(encodings)</p>
<h4 id="req-acceptslanguages-langs-">req.acceptsLanguages(langs)</h4>
<p>使用方法同 req.acceptsEncodings(encodings)</p>
<hr>
<h3 id="response">Response</h3>
<p>详细的 Response 对象 API 如下：</p>
<h4 id="res-header">res.header</h4>
<p>获取返回头</p>
<h4 id="res-status">res.status</h4>
<p>获取返回状态</p>
<h4 id="res-status-">res.status=</h4>
<p>设置返回状态，可用状态如下：</p>
<ul>
<li>100 &quot;continue&quot;</li>
<li>101 &quot;switching protocols&quot;</li>
<li>102 &quot;processing&quot;</li>
<li>200 &quot;ok&quot;</li>
<li>201 &quot;created&quot;</li>
<li>202 &quot;accepted&quot;</li>
<li>203 &quot;non-authoritative information&quot;</li>
<li>204 &quot;no content&quot;</li>
<li>205 &quot;reset content&quot;</li>
<li>206 &quot;partial content&quot;</li>
<li>207 &quot;multi-status&quot;</li>
<li>300 &quot;multiple choices&quot;</li>
<li>301 &quot;moved permanently&quot;</li>
<li>302 &quot;moved temporarily&quot;</li>
<li>303 &quot;see other&quot;</li>
<li>304 &quot;not modified&quot;</li>
<li>305 &quot;use proxy&quot;</li>
<li>307 &quot;temporary redirect&quot;</li>
<li>400 &quot;bad request&quot;</li>
<li>401 &quot;unauthorized&quot;</li>
<li>402 &quot;payment required&quot;</li>
<li>403 &quot;forbidden&quot;</li>
<li>404 &quot;not found&quot;</li>
<li>405 &quot;method not allowed&quot;</li>
<li>406 &quot;not acceptable&quot;</li>
<li>407 &quot;proxy authentication required&quot;</li>
<li>408 &quot;request time-out&quot;</li>
<li>409 &quot;conflict&quot;</li>
<li>410 &quot;gone&quot;</li>
<li>411 &quot;length required&quot;</li>
<li>412 &quot;precondition failed&quot;</li>
<li>413 &quot;request entity too large&quot;</li>
<li>414 &quot;request-uri too large&quot;</li>
<li>415 &quot;unsupported media type&quot;</li>
<li>416 &quot;requested range not satisfiable&quot;</li>
<li>417 &quot;expectation failed&quot;</li>
<li>418 &quot;i&#39;m a teapot&quot;</li>
<li>422 &quot;unprocessable entity&quot;</li>
<li>423 &quot;locked&quot;</li>
<li>424 &quot;failed dependency&quot;</li>
<li>425 &quot;unordered collection&quot;</li>
<li>426 &quot;upgrade required&quot;</li>
<li>428 &quot;precondition required&quot;</li>
<li>429 &quot;too many requests&quot;</li>
<li>431 &quot;request header fields too large&quot;</li>
<li>500 &quot;internal server error&quot;</li>
<li>501 &quot;not implemented&quot;</li>
<li>502 &quot;bad gateway&quot;</li>
<li>503 &quot;service unavailable&quot;</li>
<li>504 &quot;gateway time-out&quot;</li>
<li>505 &quot;http version not supported&quot;</li>
<li>506 &quot;variant also negotiates&quot;</li>
<li>507 &quot;insufficient storage&quot;</li>
<li>509 &quot;bandwidth limit exceeded&quot;</li>
<li>510 &quot;not extended&quot;</li>
<li>511 &quot;network authentication required&quot;</li>
</ul>
<h4 id="res-length-">res.length=</h4>
<p>设置返回头的 <code>Content-Length</code> 属性</p>
<h4 id="res-length">res.length</h4>
<p>返回返回头的 <code>Content-Length</code> 属性，当不存在 <code>Content-Length</code> 属性时，根据 <code>res.body</code> 推断</p>
<h4 id="res-body">res.body</h4>
<p>获取 res.body，当 res.body 为 null ，但返回状态仍为 200 时，koa 将会返回 404 页面。</p>
<h4 id="res-body-">res.body=</h4>
<p>设置请求返回的主要内容，可以是以下几种类型：</p>
<ul>
<li><p>string</p>
<p>Content-Type 将默认设置为 text/html 或者 text/plain，默认字符集是 utf-8，Content-Length 也将一并设置</p>
</li>
<li><p>Buffer</p>
<p>Content-Type 将默认设置为 application/octet-stream，Content-Length 也将一并设置</p>
</li>
<li><p>Stream</p>
<p>Content-Type 将默认设置为 application/octet-stream</p>
</li>
<li><p>Object</p>
<p>Content-Type 将默认设置为 application/json
注意：默认的json返回会添加空格，如果你希望压缩json返回中的空格，可以这样配置：<code>app.jsonSpaces = 0</code></p>
</li>
<li><p>null</p>
</li>
</ul>
<h4 id="res-get-field-">res.get(field)</h4>
<p>获取指定的返回头属性，属性名称区分大小写。</p>
<pre><code class="lang-javascript">var etag = this.get(&#39;ETag&#39;);</code></pre>
<h4 id="res-set-field-value-">res.set(field, value)</h4>
<p>使用给定的参数设置一个返回头属性：</p>
<pre><code class="lang-javascript">this.set(&#39;Cache-Control&#39;, &#39;no-cache&#39;);</code></pre>
<h4 id="res-set-fields-">res.set(fields)</h4>
<p>使用给定的对象一次设置多个返回头属性：</p>
<pre><code class="lang-javascript">this.set({
  &#39;Etag&#39;: &#39;1234&#39;,
  &#39;Last-Modified&#39;: date
});</code></pre>
<h4 id="res-remove-fields-">res.remove(fields)</h4>
<p>删除指定的返回头属性</p>
<h4 id="res-type">res.type</h4>
<p>获取返回头中的 Content-Type，不包括 <code>&quot;charset&quot;</code> 等属性。</p>
<pre><code class="lang-javascript">var ct = this.type;
// =&gt; &quot;image/png&quot;</code></pre>
<h4 id="res-type-">res.type=</h4>
<p>使用字符串或者文件后缀设定返回的 Content-Type</p>
<pre><code class="lang-javascript">this.type = &#39;text/plain; charset=utf-8&#39;;
this.type = &#39;image/png&#39;;
this.type = &#39;.png&#39;;
this.type = &#39;png&#39;;</code></pre>
<p>注意：当使用文件后缀指定时，koa 会默认设置好最匹配的编码字符集，比如当设定 <code>res.type = &#39;html&#39;</code> 时，koa 会默认使用 <code>&quot;utf-8&quot;</code> 字符集。但当明确使用 <code>res.type = &#39;text/html&#39;</code> 指定时，koa 不会自动设定字符集。</p>
<h4 id="res-redirect-url-alt-">res.redirect(url, [alt])</h4>
<p>返回一个 <code>302</code> 跳转到给定的 url，您也可以使用关键词 <code>back</code> 来跳转到该 url 的上一个页面（refer），当没有上一个页面时，默认会跳转到 &#39;/&#39;</p>
<pre><code class="lang-javascript">this.redirect(&#39;back&#39;);
this.redirect(&#39;back&#39;, &#39;/index.html&#39;);
this.redirect(&#39;/login&#39;);
this.redirect(&#39;http://google.com&#39;);</code></pre>
<p>如果你需要覆盖 <code>302</code> 状态码，并在跳转时返回一些文案，可以这样做：</p>
<pre><code class="lang-javascript">this.status = 301;
this.redirect(&#39;/cart&#39;);
this.body = &#39;Redirecting to shopping cart&#39;;</code></pre>
<h4 id="res-attachment-filename-">res.attachment([filename])</h4>
<p>设置返回熟悉 Content-Disposition 为 <code>&quot;attachment&quot;</code>，并告知客户端进行下载。</p>
<h4 id="res-headersent">res.headerSent</h4>
<p>判断一个响应头是否已经发送到客户端，通常用来检测客户端是否收到了错误信息。</p>
<h4 id="res-lastmodified">res.lastModified</h4>
<p>如果返回头中存在 Last-Modified 属性，则返回它。</p>
<h4 id="res-lastmodified-">res.lastModified=</h4>
<p>设置返回头中的 Last-Modified 属性，可以使用时间对象或者时间字符串。</p>
<pre><code class="lang-javascript">this.response.lastModified = new Date();</code></pre>
<h4 id="res-etag-">res.etag=</h4>
<p>设置返回头的 Etag 字段。koa 不提供关于 Etag 的获取方法。</p>
<pre><code class="lang-javascript">this.response.etag = crypto.createHash(&#39;md5&#39;).update(this.body).digest(&#39;hex&#39;);</code></pre>
<hr>
<h3 id="-benchmarks-">性能（Benchmarks）</h3>
<p>挂载不同数量的中间件，wrk 得出 benchmarks 如下：</p>
<pre><code>1 middleware
8367.03

5 middleware
8074.10

10 middleware
7526.55

15 middleware
7399.92

20 middleware
7055.33

30 middleware
6460.17

50 middleware
5671.98

100 middleware
4349.37</code></pre>
<p>一般来说，我们通常要使用约50个中间件，按这个标准计算，单应用可支持 340,260 请求/分钟，即 20,415,600 请求/小时，也就是约 4.4 亿 请求/天。</p>
<hr>
<h3 id="-">学习资料</h3>
<p>发现更多第三方的 koa 中间件，或者一起来参与社区的讨论和建设吧：</p>
<ul>
<li><a href="https://github.com/koajs/koa">GitHub repository</a></li>
<li><a href="https://github.com/koajs/examples">Examples</a></li>
<li><a href="https://github.com/koajs/koa/wiki">Middleware</a></li>
<li><a href="https://github.com/koajs/koa/wiki">Wiki</a></li>
<li><a href="https://plus.google.com/communities/101845768320796750641">G+ Community</a></li>
<li><a href="https://groups.google.com/forum/#!forum/koajs">Mailing list</a></li>
<li><a href="https://github.com/koajs/koa/blob/master/docs/guide.md">Guide</a></li>
<li><a href="https://github.com/koajs/koa/blob/master/docs/faq.md">FAQ</a></li>
</ul>
<hr>
</div></section><section><div class="content"><h1 id="links">Links</h1><p>Community links to discover third-party middleware for Koa, full runnable examples,
thorough guides and more! If you have questions join us in IRC!
</p><ul><li><a href="https://github.com/koajs/koa">GitHub repository</a></li><li><a href="https://github.com/koajs/examples">Examples</a></li><li><a href="https://github.com/koajs/koa/wiki">Middleware</a></li><li><a href="https://github.com/koajs/koa/wiki">Wiki</a></li><li><a href="https://plus.google.com/communities/101845768320796750641">G+ Community</a></li><li><a href="https://groups.google.com/forum/#!forum/koajs">Mailing list</a></li><li><a href="https://github.com/koajs/koa/blob/master/docs/guide.md">Guide</a></li><li><a href="https://github.com/koajs/koa/blob/master/docs/faq.md">FAQ</a></li><li><strong>#koajs</strong> on freenode</li></ul></div></section></body></html>